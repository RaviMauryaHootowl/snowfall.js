{"version":3,"sources":["webpack://snowfall/webpack/bootstrap","webpack://snowfall/./src/snowfall.js","webpack://snowfall/./src/vec2.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA,aAAa,mBAAO,CAAC,6BAAQ;;AAE7B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;ACvPA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"snowfall.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/snowfall.js\");\n","const vec2 = require('./vec2')\r\n\r\nconst appContainer = document.querySelector('#snow-container')\r\n\r\nconst canvas = document.createElement('canvas')\r\nconst ctx = canvas.getContext('2d')\r\n\r\nlet gravity = vec2.create(0, 0)\r\nlet wind = vec2.create(0, 0)\r\nlet density = 250\r\n\r\nlet snowflakes = []\r\n\r\nlet bg = '#000000'\r\nlet primary = '#8d90b7'\r\nlet secondary = '#ffffff'\r\n\r\nlet amplitude = 0.00\r\nlet frequency = 0.00\r\n\r\nfunction start (config = {}) {\r\n  if (config.bg !== undefined) {\r\n    bg = config.bg\r\n  }\r\n\r\n  if (config.primary !== undefined) {\r\n    primary = config.primary\r\n  }\r\n\r\n  if (config.secondary !== undefined) {\r\n    secondary = config.secondary\r\n  }\r\n\r\n  if (config.density !== undefined) {\r\n    density = config.density\r\n  }\r\n\r\n  if (config.wave !== undefined) {\r\n    if (config.wave.amplitude !== undefined) {\r\n      amplitude = config.wave.amplitude\r\n    }\r\n\r\n    if (config.wave.frequency !== undefined) {\r\n      frequency = config.wave.frequency\r\n    }\r\n  }\r\n\r\n  if (config.gravity !== undefined) {\r\n    if (config.gravity.angle !== undefined && config.gravity.strength !== undefined) {\r\n      setGravity(config.gravity.angle, config.gravity.strength)\r\n    }\r\n\r\n    if (config.gravity.angle !== undefined && config.gravity.strength === undefined) {\r\n      setGravity(config.gravity.angle, 0.6)\r\n    }\r\n\r\n    if (config.gravity.angle === undefined && config.gravity.strength !== undefined) {\r\n      setGravity(90, config.gravity.strength)\r\n    }\r\n  }\r\n\r\n  if (config.wind !== undefined) {\r\n    if (config.wind.angle !== undefined && config.wind.strength !== undefined) {\r\n      setWind(config.wind.angle, config.wind.strength)\r\n    }\r\n\r\n    if (config.wind.angle !== undefined && config.wind.strength === undefined) {\r\n      setWind(config.wind.angle, 0.0)\r\n    }\r\n\r\n    if (config.wind.angle === undefined && config.wind.strength !== undefined) {\r\n      setWind(0.0, config.wind.strength)\r\n    }\r\n  }\r\n\r\n  canvas.width = appContainer.offsetWidth\r\n  canvas.height = appContainer.offsetHeight\r\n  appContainer.appendChild(canvas)\r\n\r\n  snowflakes = makeSnowflakes(requiredSnowflakes())\r\n\r\n  window.onresize = onResize\r\n  window.requestAnimationFrame(onEnterFrame)\r\n}\r\n\r\nfunction onResize () {\r\n  canvas.width = appContainer.offsetWidth\r\n  canvas.height = appContainer.offsetHeight\r\n\r\n  snowflakes = makeSnowflakes(requiredSnowflakes())\r\n}\r\n\r\nfunction onEnterFrame () {\r\n  update()\r\n  render()\r\n\r\n  window.requestAnimationFrame(onEnterFrame)\r\n}\r\n\r\nlet t = 0\r\n\r\nconst w = vec2.create(0, 0)\r\nconst g = vec2.create(0, 0)\r\n\r\nlet sine = null\r\n\r\nfunction update () {\r\n  snowflakes.forEach(snowflake => {\r\n    w.x = wind.x\r\n    w.y = wind.y\r\n\r\n    w.multiplyScalar(snowflake.size + snowflake.random)\r\n\r\n    snowflake.pos.add(w)\r\n\r\n    g.x = gravity.x\r\n    g.y = gravity.y\r\n\r\n    g.multiplyScalar(snowflake.size + snowflake.random)\r\n\r\n    snowflake.pos.add(g)\r\n\r\n    const phase = snowflake.noise\r\n\r\n    sine = vec2.create(\r\n      amplitude * Math.sin((frequency * t) + phase),\r\n      0\r\n    )\r\n\r\n    snowflake.pos.add(sine)\r\n\r\n    if (snowflake.pos.x > canvas.width) {\r\n      snowflake.pos.x = 0\r\n    }\r\n\r\n    if (snowflake.pos.x < 0) {\r\n      snowflake.pos.x = canvas.width\r\n    }\r\n\r\n    if (snowflake.pos.y > canvas.height) {\r\n      snowflake.pos.y = 0\r\n      snowflake.pos.x = Math.random() * canvas.width\r\n    }\r\n\r\n    if (snowflake.pos.y < 0) {\r\n      snowflake.pos.y = canvas.height\r\n      snowflake.pos.x = Math.random() * canvas.width\r\n    }\r\n  })\r\n\r\n  t += 1\r\n}\r\n\r\nfunction render () {\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\r\n\r\n  if (bg) {\r\n    ctx.fillStyle = bg\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n  }\r\n\r\n  const bgSize = 7\r\n\r\n  const foreground = snowflakes.filter(x => x.size >= bgSize)\r\n  const background = snowflakes.filter(x => x.size < bgSize)\r\n\r\n\r\n\r\n  ctx.fillStyle = primary\r\n  background.forEach(snowflake => {\r\n    ctx.beginPath()\r\n    drawCircle(snowflake.pos, snowflake.size)\r\n    ctx.fill()\r\n  })\r\n\r\n  ctx.fillStyle = secondary\r\n  foreground.forEach(snowflake => {\r\n    ctx.beginPath()\r\n    drawCircle(snowflake.pos, snowflake.size)\r\n    ctx.fill()\r\n  })\r\n}\r\n\r\nfunction makeSnowflakes (num) {\r\n  let result = []\r\n\r\n  while (num--) {\r\n    result.push({\r\n      pos: vec2.create(\r\n        Math.random() * canvas.width,\r\n        Math.random() * canvas.height\r\n      ),\r\n      size: 3 + (Math.random() * 5),\r\n      // Random value, just to add some uncertainty\r\n      noise: Math.random() * 10,\r\n      amplitude: Math.random() * 2,\r\n      frequency: Math.random() * 0.01,\r\n      random: Math.random()\r\n    })\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n// This function figures out how many snowflakes we should use for our given canvas size\r\n// Just setting a fixed number of snowflakes would give an uneven distribution of\r\n// snowflakes across different screen sizes, for example.\r\nfunction requiredSnowflakes () {\r\n  const tenEightyPee = 1920 * 1080\r\n  const thisScreen = canvas.width * canvas.height\r\n  const snowflakeCount = Math.round(density * (thisScreen / tenEightyPee))\r\n\r\n  return snowflakeCount\r\n}\r\n\r\nfunction drawCircle (position, radius) {\r\n  ctx.arc(position.x, position.y, radius, 0, 2 * Math.PI, false)\r\n}\r\n\r\nfunction restart () {\r\n  snowflakes = makeSnowflakes(requiredSnowflakes())\r\n}\r\n\r\nfunction setGravity (degrees, strength) {\r\n  gravity = vec2.fromDegrees(degrees)\r\n  gravity.multiplyScalar(strength)\r\n}\r\n\r\nfunction setWind (degrees, strength) {\r\n  wind = vec2.fromDegrees(degrees)\r\n  wind.multiplyScalar(strength)\r\n}\r\n\r\nmodule.exports = {\r\n  start,\r\n  setGravity,\r\n  setWind,\r\n  setDensity: d => {\r\n    density = d\r\n    restart()\r\n  },\r\n  setPrimary: colour => {\r\n    primary = colour\r\n  },\r\n  setSecondary: colour => {\r\n    secondary = colour\r\n  }\r\n}\r\n","function create (_x, _y) {\r\n  let x = _x\r\n  let y = _y\r\n\r\n  const add = v => {\r\n    x += v.x\r\n    y += v.y\r\n  }\r\n\r\n  const addScalar = s => {\r\n    x += s\r\n    y += s\r\n  }\r\n\r\n  const divide = v => {\r\n    x /= v.x\r\n    y /= v.y\r\n  }\r\n\r\n  const divideScalar = s => {\r\n    x /= s\r\n    y /= s\r\n  }\r\n\r\n  const dot = v => {\r\n    return (x * v.x) + (y * v.y)\r\n  }\r\n\r\n  const getLength = () => {\r\n    return Math.sqrt((x * x) + (y * y))\r\n  }\r\n\r\n  const getOpposite = v => {\r\n    return create(-v.x, -v.y)\r\n  }\r\n\r\n  const getPerp = () => {\r\n    return create(-y, x)\r\n  }\r\n\r\n  const isEqualTo = v => {\r\n    return (x == v.x && y == v.y)\r\n  }\r\n\r\n  const multiply = v => {\r\n    x *= v.x\r\n    y *= v.y\r\n  }\r\n\r\n  const multiplyScalar = s => {\r\n    x *= s\r\n    y *= s\r\n  }\r\n\r\n  const normalise = () => {\r\n    let l = getLength()\r\n\r\n    x = x / l\r\n    y = y / l\r\n  }\r\n\r\n  const setLength = l => {\r\n    normalise()\r\n    multiplyScalar(l)\r\n  }\r\n\r\n  const subtract = v => {\r\n    x -= v.x\r\n    y -= v.y\r\n  }\r\n\r\n  const subtractScalar = s => {\r\n    x -= s\r\n    y -= s\r\n  }\r\n\r\n  return {\r\n    add,\r\n    addScalar,\r\n    clone,\r\n    divide,\r\n    divideScalar,\r\n    dot,\r\n    getLength,\r\n    getOpposite,\r\n    getPerp,\r\n    isEqualTo,\r\n    multiply,\r\n    multiplyScalar,\r\n    normalise,\r\n    setLength,\r\n    subtract,\r\n    subtractScalar,\r\n    set x (_x) {\r\n      x = _x\r\n    },\r\n    get x () {\r\n      return x\r\n    },\r\n    set y (_y) {\r\n      y = _y\r\n    },\r\n    get y () {\r\n      return y\r\n    },\r\n  }\r\n}\r\n\r\nconst fromDegrees = degrees => {\r\n  const rad = degrees * (Math.PI / 180)\r\n  return create(Math.cos(rad), Math.sin(rad))\r\n}\r\n\r\nconst clone = v => {\r\n  return create(v.x, v.y)\r\n}\r\n\r\nmodule.exports = {\r\n  clone,\r\n  create,\r\n  fromDegrees,\r\n}\r\n"],"sourceRoot":""}